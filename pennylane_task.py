# -*- coding: utf-8 -*-
"""PennyLane_Task.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11Q-gIMITq0GC3mrHRi0dHoHnKXHksF7x

# Task 1: Create a Bell State Circuit
Build a quantum circuit that generates the Bell state



Use 2 qubits

Use qml.probs() to display the probability distribution

Bonus: visualize the statevector or show measurement samples

##Create the Bell State Circuit
"""

# Install PennyLane
!pip install pennylane

# Imports
import pennylane as qml
from pennylane import numpy as np
import matplotlib.pyplot as plt
import collections

# Set up the quantum device (no shots for probability & statevector)
dev = qml.device("default.qubit", wires=2)

# Bell State Circuit â€“ Get Probabilities
@qml.qnode(dev)
def bell_circuit():
    qml.Hadamard(wires=0)        # Superposition
    qml.CNOT(wires=[0, 1])       # Entanglement
    return qml.probs(wires=[0, 1])

probs = bell_circuit()
print("ðŸ”¹ Probability Distribution:", probs)

# Visualize the probability distribution
plt.bar(['00', '01', '10', '11'], probs)
plt.title("Probability Distribution of Bell State")
plt.xlabel("States")
plt.ylabel("Probability")
plt.show()

# Bonus: Show the statevector
@qml.qnode(dev)
def bell_statevector():
    qml.Hadamard(wires=0)
    qml.CNOT(wires=[0, 1])
    return qml.state()

state = bell_statevector()
print("ðŸ”¸ Statevector:", state)

# Bonus: Show measurement samples (with shots)
dev_sample = qml.device("default.qubit", wires=2, shots=1000)

@qml.qnode(dev_sample)
def bell_sample_many():
    qml.Hadamard(wires=0)
    qml.CNOT(wires=[0, 1])
    return qml.sample(wires=[0, 1])

samples = bell_sample_many()

# Count and show the measurement results
counts = collections.Counter([tuple(s) for s in samples])
print("ðŸ”¹ Measurement Counts (1000 shots):", counts)

# Bar plot of measurement results
labels = ['00', '01', '10', '11']
values = [counts.get((0, 0), 0), counts.get((0, 1), 0),
          counts.get((1, 0), 0), counts.get((1, 1), 0)]

plt.bar(labels, values)
plt.title("Measurement Results (1000 shots)")
plt.xlabel("States")
plt.ylabel("Counts")
plt.show()

"""# Task 2: Build a GHZ State for 3 Qubits
Construct a circuit that prepares a 3-qubit GHZ state:

Use Hadamard and CNOT gates

Measure using qml.probs(wires=[0, 1, 2])

Optional: extend to 4 qubits
"""

# Install PennyLane
!pip install pennylane

# Imports
import pennylane as qml
from pennylane import numpy as np
import matplotlib.pyplot as plt
import collections

# 3-Qubit GHZ State
dev = qml.device("default.qubit", wires=3)

@qml.qnode(dev)
def ghz_3_circuit():
    qml.Hadamard(wires=0)
    qml.CNOT(wires=[0, 1])
    qml.CNOT(wires=[1, 2])
    return qml.probs(wires=[0, 1, 2])

probs = ghz_3_circuit()
print("ðŸ”¹ 3-Qubit GHZ State Probabilities:", probs)

# Plot probability distribution
labels = ['000', '001', '010', '011', '100', '101', '110', '111']
plt.bar(labels, probs)
plt.title("Probability Distribution (3-Qubit GHZ)")
plt.xlabel("States")
plt.ylabel("Probability")
plt.show()

# Bonus: 4-Qubit GHZ State
dev4 = qml.device("default.qubit", wires=4)

@qml.qnode(dev4)
def ghz_4_circuit():
    qml.Hadamard(wires=0)
    qml.CNOT(wires=[0, 1])
    qml.CNOT(wires=[1, 2])
    qml.CNOT(wires=[2, 3])
    return qml.probs(wires=[0, 1, 2, 3])

probs4 = ghz_4_circuit()
print("ðŸ”¸ 4-Qubit GHZ State Probabilities:", probs4)

# Plot for 4-qubit
labels4 = [f"{i:04b}" for i in range(16)]
plt.bar(labels4, probs4)
plt.title("Probability Distribution (4-Qubit GHZ)")
plt.xlabel("States")
plt.ylabel("Probability")
plt.xticks(rotation=90)
plt.show()

"""# Task 3: Rotation + Measurement Circuit
Design a single-qubit rotation circuit using RX, RY, or RZ gates.

Make the rotation angle a variable input

Return the expectation value of PauliZ

Plot how the output changes as you vary the input angle


"""

# Install PennyLane
!pip install pennylane

# Imports
import pennylane as qml
from pennylane import numpy as np
import matplotlib.pyplot as plt

# Define a single-qubit device
dev = qml.device("default.qubit", wires=1)

# Define the quantum circuit with a variable angle
@qml.qnode(dev)
def rotation_circuit(theta):
    qml.RY(theta, wires=0)  # You can switch to RX or RZ here
    return qml.expval(qml.PauliZ(0))  # Measure expectation of PauliZ

# Test: Evaluate the circuit at a single angle
angle = np.pi / 4
expect_val = rotation_circuit(angle)
print(f"ðŸ”¹ Expectation value at Î¸ = Ï€/4: {expect_val:.3f}")

# Plot expectation vs. angle
angles = np.linspace(0, 2 * np.pi, 100)
expectations = [rotation_circuit(a) for a in angles]

plt.plot(angles, expectations)
plt.title("Expectation âŸ¨ZâŸ© vs Rotation Angle Î¸ (RY)")
plt.xlabel("Î¸ (radians)")
plt.ylabel("Expectation value âŸ¨ZâŸ©")
plt.grid(True)
plt.show()

"""## Task 4: Simple Variational Optimization
Create a cost function that depends on a gate parameter, and optimize it using PennyLaneâ€™s gradient descent optimizer.

Use a rotation gate like RX, and minimize expval(PauliZ)

Log or print cost at each step

Output the optimal parameter found

plot the cost function curve
"""

# Install PennyLane
!pip install pennylane

# Imports
import pennylane as qml
from pennylane import numpy as np
import matplotlib.pyplot as plt

# Set up 1-qubit device
dev = qml.device("default.qubit", wires=1)

# Define quantum circuit with parameter
@qml.qnode(dev)
def circuit(theta):
    qml.RX(theta, wires=0)
    return qml.expval(qml.PauliZ(0))  # Expectation of PauliZ

# Define cost function: we want to minimize this
def cost(theta):
    return circuit(theta)

# Initialize parameter and optimizer
theta = np.array(0.5, requires_grad=True)
opt = qml.GradientDescentOptimizer(stepsize=0.1)

# Optimization loop
steps = 50
costs = []

print("ðŸ”§ Optimization Log:")
for i in range(steps):
    theta, curr_cost = opt.step_and_cost(cost, theta)
    costs.append(curr_cost)
    print(f"Step {i+1:2d} | Î¸ = {theta:.4f} | Cost = {curr_cost:.6f}")

print(f"\nâœ… Optimal Î¸: {theta:.4f}")
print(f"âœ… Minimum Cost: {cost(theta):.6f}")

# Plot the cost function curve
plt.plot(range(steps), costs)
plt.title("Cost Function over Optimization Steps")
plt.xlabel("Step")
plt.ylabel("Cost (âŸ¨ZâŸ© after RX)")
plt.grid(True)
plt.show()

"""# Task 5: Measurement Comparison
Build a 1- or 2-qubit circuit and compare results from:

qml.probs()

qml.sample()

qml.expval()

Explain how they differ in output and when you'd use each.

Discuss why probs() is deterministic but sample() is random.
"""

# Install PennyLane
!pip install pennylane

# Imports
import pennylane as qml
from pennylane import numpy as np
import matplotlib.pyplot as plt
import collections

# Angle for rotation
theta = np.pi / 4  # 45 degrees

# Device without shots (analytic mode for probs and expval)
dev_analytic = qml.device("default.qubit", wires=1)

# Device with shots (sampling mode)
dev_sample = qml.device("default.qubit", wires=1, shots=1000)

# Circuit for qml.probs and qml.expval
@qml.qnode(dev_analytic)
def circuit_probs_expval(theta):
    qml.RY(theta, wires=0)
    return qml.probs(wires=0), qml.expval(qml.PauliZ(0))

# Circuit for qml.sample
@qml.qnode(dev_sample)
def circuit_sample(theta):
    qml.RY(theta, wires=0)
    return qml.sample(wires=0)

# Run all three types of measurements
probs, expval = circuit_probs_expval(theta)
samples = circuit_sample(theta)

# Output results
print("ðŸ”¹ qml.probs():", probs)
print("ðŸ”¸ qml.expval():", expval)
print("ðŸ”¹ qml.sample() (first 10):", samples[:10])

# Count sample results (0 or 1)
counts = collections.Counter(samples)
print("ðŸ”¸ Sample Counts:", dict(counts))

# Plot sample histogram
labels = ['0', '1']
values = [counts.get(0, 0), counts.get(1, 0)]
plt.bar(labels, values)
plt.title("Sampled Measurement Histogram (1000 shots)")
plt.xlabel("Measured State")
plt.ylabel("Counts")
plt.show()

"""Why Is probs() Deterministic but sample() Random?

qml.probs() is computed mathematically from the quantum state vector, so it always returns the same result given the same input â€” like getting the exact dice odds (â…™ for each face).

qml.sample() mimics what you would see on a real quantum computer: you donâ€™t get probabilities directly â€” you get measurement results (0 or 1) with some randomness. Re-running it will yield different results, unless you set a random seed.
"""